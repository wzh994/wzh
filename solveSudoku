#include"sudoku.h"
#include<fstream>

void Sudoku::DFS(int count)
{
	if (count == 81)
	{
		for (int i = 0; i < 9; ++i)
		{
			for(int j = 0; j < 8; ++j)
			fprintf(file2,"%c ", range[i][j]);
			fprintf(file2, "%c\n", range[i][8]);
		}
		fputs("\n",file2);
		return;
	}
	int row = count / 9;  //x坐标
	int col = count % 9;  //y坐标
	if (range[row][col] == '0')
	{
		for (int i = 1; i <= 9; i++)
		{
			range[row][col] = i + '0';

			int flag = 1;
			int j;
			//行
			for (j = 0; j < 9; j++)    
			{
				if (range[row][j] == range[row][col] && j != col)
					flag = 0;
			}
			//列
			for (j = 0; j < 9; j++)
			{
				if (range[j][col] == range[row][col] && j != row)
					flag = 0;
			}
			//宫
			int baseRow = row / 3 * 3;
			int baseCol = col / 3 * 3;
			for (j = baseRow; j < baseRow + 3; j++)
			{
				for (int k = baseCol; k < baseCol + 3; k++)
				{
					if (range[j][k] == range[row][col] && (j != row || k != col))
						flag = 0;
				}
			}
			//如果这一个点通过
			if (flag)
			{
				DFS(count + 1);//继续下一个
			}

		}
		range[row][col] = '0';
	}
	else
		DFS(count + 1);
}
void Sudoku::solveSudoku(string path)
{
	ifstream file(path);
		errno_t err;
		err = fopen_s(&file2, "sudoku.txt", "w+");
		cout << "打开sudoku.txt" << endl;
	if (file)
	{
		int total = 0;
		string temp[9];
		string str;
		int line = 0;
		while (total < 1000000 && getline(file, str))
		{
			temp[line] = str; 
			line++;
			if (line == 9)//读入了一个数独
			{
				for (int i = 0; i < 9; i++)
					for (int j = 0; j < 9; j++)
					{
						range[i][j] = temp[i][2 * j]; //处理格式，读入偶数列
						if (range[i][j] < '0' || range[i][j] > '9')
						{
							break;
						}

					}
				getline(file, str);//格式问题
				line = 0;
				total++;
				long count = 0;
				DFS(0);
			}
		}
	}
	else
		cout << "error:未找到该路径，请确认路径" <<path << endl;

}
